# Broken Authentication

## What is Authentication

authentication is the act of proving an assertion  
in this module which is more app security focused, authentication could be described as determining if an entity is who it claims to be 

most widespread form of authentication used in web apps is a login form   
usually the first line of defense against unauthorized access 

keep in mind this is not authorization which is the process of approving or disapproving a request from a given, authenticated, entity   

most companies offer certain services for which their customers have to register and authenticate  
our goal is to verify if these login forms are implemented securely and if we can bypass them to gain unauthorized access   

## Overview of Authentication Methods 

during the authentication phase the entity who wants to auth sends an `identification string` which could be an ID, username, email, etc.   
the most common type of data that an auth process requires to be sent with the identification string is a password   
however, the type of additional data can vary in type 

### Multi-factor authentication 

MFA or 2FA can result in a much more robust authentication process   

3 domains of factors: 
- something you know 
- something you have 
- something you are 

### Form-based authentication 

most common authentication methods for web apps is form-based authentication   
app presents an HTML form where user inputs username and password; access granted after comparing the received data against a backend 

after successful login the app server creates a session tied to a unique key (usually stored in a cookie)   
key is passed between the client and the web app on every subsequent communication for the session to be maintained 

some require multiple steps of authentication like also using a one-time password OTP   
these can originate from a hardware device or app   
usually only last for a limited amount of time and are valid for only one login attempt   

some multi-step procedures suffer from `business logic` vulnerabilities like step 3 might take for granted that step 1 and 2 have been completed successfully 

### HTTP based authentication 

app server can specify different auth schemes such as basic, digest, and NTLM   
all schemes revolve around the `401` status code and the `WWW-Authenticate` response header   
used by app servers to challenge a client request and provide authentication details (challenge-response process)

when using http-based auth the `authorization header` also holds the authentication data and should be present in every request for the user to be authenticated 

from a network pov this can be less secure that FBA because every request contains authentication data   
for example, the browser encodes the username and password using base64; the authorization header will contain the base64 encoded credentials in every request  
therefore, an attacker that can capture the traffic in plaintext will also capture credentials   
the same would happen in FBA but just not for every request 

an example header that a browser sends for basic authentication would look like: 

```shell-session
GET /basic_auth.php HTTP/1.1
Host: brokenauth.hackthebox.eu
Cache-Control: max-age=0
Authorization: Basic YWRtaW46czNjdXIzcDQ1NQ==
```

it specifies the authentication method, like Basic, and the token which can be decoded to `admin:s3cur3p455`

digest and NTLM are more robust because they use hashed data and could contain a nonce, but these can still be cracked and might also be vulnerable to reusing a captured token 

### Other forms of authentication

uncommon but also possible that authentication is performed by checking the source IP address  
a request from localhost or trusted IP could be allowed because developers assumed nobody would use them 

modern apps can also use third parties to authenticate users like `SAML` and APIs usually require a authentication form which are often multi-step 

attacks against API authentication/authorization, SSO, and OAuth have the same foundations as attacks against classic web apps 

### Login example 

a typical scenario for home banking authentication: 
- requests our ID which could be seven-digit number generated by app or a username 
- app requests a password for the given ID 
- user must provide an OTP 
- app checks if the ID, password, and OTP are valid 

## Overview of Attacks Against Authentication 

auth attacks can take place against the three domains: 
- has
- is
- knows

### Attacking the HAS domain 

this can seem simple because it looks like it comes down to if we have the hardware token or not  
things can be more complicated though: 
- a badge could be cloned without taking it over
- a crypto algorithm used to generate OTP could be broken
- a physical device could be stolen 

a long-range antenna can easily cover a distance of 50cm and clone a classic NFC badge   
there are also many other social-engineering based methods to clone a card 

### Attacking the IS domain 

this may seem as the most difficult to attack  
if something relies on something to prove their identity and that something gets compromised, then they lose that method because there is no way to change that part of them   

retina, fingerprint, and facial recognition have all been proved to be breakable   
these can be broken through third-party leak, high-definition picture, a skimmer or even someone who might steal the right glass you drank from 

companies that sell biometric smart locks have been breached to release all of its users fingerprints and facial patterns 

### Attacking the knows domain 

we will deal with this in this module  

things that the user knows like a username and password in methods like FBA 

## Default Credentials 

it is common to find devices with default credentials due to human error or a breakdown in or lack of proper process  

Rapid7's under the hoodie report said that known default credentials resulting in unauthorized access were 21% of their engagements 

systems like ICS environments even prefer known credentials because it makes it easier than storing a complex set of credentials securely   
this however does not justify default credentials 

it is a mandatory step of security hardening to change default passwords at an early stage of app development 

another common thing is vendors use hardcoded hidden accounts in their products   
https://nvd.nist.gov/vuln/detail/CVE-2020-29583 - researchers found a hardcoded account with admin privileges and an unchangeable password 

CIRT.net and SecLists have databases used to collect default credentials split by vendors   

https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv - SCADA StrangeLove published list of well-known ICS passwords, both default and hardcoded 

always good to test known passwords against systems with lists like these, for example if you found a Cisco device then you could use https://www.cirt.net/passwords?criteria=cisco

### Hands-on example 

https://academy.hackthebox.com/storage/modules/80/scripts/basic_bruteforce_py.txt
https://academy.hackthebox.com/storage/modules/80/scripts/basic_bruteforce_php.txt

first we need to capture the request parameters being used to login: 

![](Images/Pasted%20image%2020240216175336.png)

we can see from the title that the target is SCADA: 

![](Images/Pasted%20image%2020240216175540.png)

in our default script we can see that we are using the default passwords CSV:

![](Images/Pasted%20image%2020240216180525.png)

I also need to modify the `unpack()` method to accommodate for the `scada-pass.csv` format: 

![](Images/Pasted%20image%2020240216185942.png)

then modify the data being sent in the POST requests to match the captured request: 

![](Images/Pasted%20image%2020240216181957.png)

then we can find valid credentials:

![](Images/Pasted%20image%2020240216185927.png)

## Weak Bruteforce Protections 

some of the most common mechanisms to prevent automated attacks are: 
- CAPTCHA
- rate limits 

there are also custom web dev security mechanisms that could be less robust and may contain bugs that we could exploit 

### Captcha 

completely automated public turing test to tell computers and humans apart   
typing a word, audio sample, matching an image, math operations 

has been bypassed in the past but still pretty effective against automated attacks   
an app should at least require a user to solve after a few failed attempts   

having weak versions like name of image made up of chars contained within the image is still better than no protections 

for example really weak protections would be like having the answer in the `id` attribute: 

![](Images/Pasted%20image%2020240219125922.png)

these types of weak setups are rare but still always worth checking the source code for them 

### Rate limiting 

having a counter that increments after each failed attempt lets the app block a user that has failed multiple times within a certain amount of time 

when the tool used isn't aware of these types of protections, like basic brute forces, they will just try username and password combos that aren't actually validated   
a simple workaround is to modify tool to understand messages related to rate-limiting 

https://academy.hackthebox.com/storage/modules/80/scripts/rate_limit_check_py.txt

![](Images/Pasted%20image%2020240219130533.png)

in the above code we configure a wait time and a lock message to look for 

after being blocked the app might also require some manual operation like a confirmation code sent by email or text   
rate limiting doesn't always have a cool-down period   
could also implement questions for the user to answer 

most standard rate-limiting implementations impose a delay after `N` failed attempts   
this can be improved by increasing the delay and clustering requests by username, source IP, browser user-agent, etc. 

mature frameworks have brute-force protections built-in or use external plugins   
as a last resort major webservers like apache httpd or nginx could be used to perform rate-limiting on a given login page 

### Insufficient protections 

when an attacker can tamper with data taken into consideration to increase security they can bypass all or some protections   
changing the user-agent is easy  
some web apps or WAF leverage headers like `X-Forwarded-For` to guess the actual source IP address; done because many ISP hide users behind a NAT   
blocking an IP without the help of `X-Forwarded-For` may result in blocking all users behind the specific NAT  

an example vulnerable app would be like: 

```php
<?php
// get IP address
if (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {
	$realip = array_map('trim', explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']))[0];
} else if (array_key_exists('HTTP_CLIENT_IP', $_SERVER)) {
	$realip = array_map('trim', explode(',', $_SERVER['HTTP_CLIENT_IP']))[0];
} else if (array_key_exists('REMOTE_ADDR', $_SERVER)) {
	$realip = array_map('trim', explode(',', $_SERVER['REMOTE_ADDR']))[0];
}

echo "<div>Your real IP address is: " . htmlspecialchars($realip) . "</div>";
?>
```

these can be bypassed by simply crafting an `X-Forwarded-For` header: 

```python
headers = {
  "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36",
  "X-Forwarded-For": "1.2.3.4"
}
```

the same would work for web apps that grant access based on the user's source IP   

no web app should rely on a single, tamperable element as a security protection   
there is no reliable way to identify an actual IP address of a user behind a NAT   
therefore it is better to implement protections that slow down the attacker as much as possible   
stronger captchas and lockouts work well but generally MFA is still the best 

our target looks to have no lockout but we can try to avoid the IP filters by changing our `X-Forwarded-For` header to be the localhost IP: 

![](Images/Pasted%20image%2020240219161332.png)

![](Images/Pasted%20image%2020240219161442.png)

## Brute Forcing Usernames 

many web apps allow us to identify usernames and often they are reused to access other services like FTP, RDP, and SSH 

usernames are often much less complicated than passwords  
with a list of valid usernames an attacker can narrow down the scope of a brute force attack and carry out targeted attacks   
also a common password can be sprayed against a list of valid accounts 

usernames can also be harvested by web crawlers and using public info like company profiles and social networks 

protection against username enumeration can harm UX because letting the user know whether or not their username is valid could help attackers: 

![](Images/Pasted%20image%2020240219172915.png)

![](Images/Pasted%20image%2020240219172927.png)

### User unknown attack

attackers can brute force for error messages like "the password you entered for the username X is incorrect"   
always make sure to look for usernames like helpdesk, tech, admin, demo, guest, etc. 

if our target has an "unknown username" message we can do a brute force attack with `wfuzz` and a reverse string match against the response text with `--hs "Unknown username"`:

![](Images/Pasted%20image%2020240219175538.png)

```shell
wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d "Username=FUZZ&Password=dummypass" --hs "Unknown username" http://brokenauthentication.hackthebox.eu/user_unknown.php
```

remember that we aren't concerned with the password right now so we used a dummy one in the above command

### Username existence inference 

sometimes the web app doesn't explicitly say that it doesn't know a username but you can still infer it   
for example some sites will prefill the username input if it is valid; quite common on mobile websites 

although uncommon, it is also possible for cookies are set when a username is valid   
for example, to check for password attempts using client-side controls the app could set a cookie named failed_login 

### Timing attack 

some authentication functions can contain flaws, for example if a function checks the username and password sequentially 

an example of vulnerable code would be: 

```php
<?php
// connect to database
$db = mysqli_connect("localhost", "dbuser", "dbpass", "dbname");

// retrieve row data for user
$result = $db->query('SELECT * FROM users WHERE username="'.safesql($_POST['user']).'" AND active=1');

// $db->query() replies True if there are at least a row (so a user), and False if there are no rows (so no users)
if ($result) {
  // retrieve a row. don't use this code if multiple rows are expected
  $row = mysqli_fetch_row($result);

  // hash password using custom algorithm
  $cpass = hash_password($_POST['password']);
  
  // check if received password matches with one stored in the database
  if ($cpass === $row['cpassword']) {
	echo "Welcome $row['username']";
  } else {
    echo "Invalid credentials.";
  } 
} else {
  echo "Invalid credentials.";
}
?>
```

in the above example, if the username matches the requested one then it will hash the provided password and compare it   
however if the username isn't valid then the function ends with a generic message 
if the hashing algo is strong enough then there is timing differences between a valid and invalid username  
this can be avoided by checking the username and password at the same time so they have similar time for both valid and invalid usernames 

https://academy.hackthebox.com/storage/modules/80/scripts/timing_py.txt
https://academy.hackthebox.com/storage/modules/80/scripts/timing_php.txt

if we use the above script on the php app: 

```shell
python3 timing.py /opt/useful/SecLists/Usernames/top-usernames-shortlist.txt
```

we can see the differences in response times: 

![](Images/Pasted%20image%2020240219181804.png)

if hashing algos are faster then the differences will be less noticeable but the attack would still be possible by repeating a large number of requests to create a model   
modern apps will likely have robust algorithms that make offline brute force attacks as slow as possible 

many apps still need to consider the CPU time and RAM usage to calculate these hashes for the amount of users they have   
for example LinkedIn using bcrypt would need six servers just to let all of their users log in 

### Enumerate through password reset 

reset forms are often less protected than login ones   
very often leak info about valid or invalid usernames, for example it might send messages like "you should receive a message shortly" and "username unknown, check your data" 

noisy because valid users will probably receive an email that asks for password reset 

### Enumerate through registration form 

registration forms typically tell the user that a username already exists or provides other tells   
attackers can register common usernames like admin, administrator, and tech to enumerate valid ones   

a secure registration form should implement a captcha before checking if the selected username exists   

an interesting feature of email addresses is `sub-addressing`  
https://tools.ietf.org/html/rfc5233  

any `+tag` in the left part of an email should be ignored by the mail transport agent MTA   
writing to an email like `student+htb@hackthebox.eu` will deliver the email to `student@hackthebox.eu` and if filters are supported and properly configed it will be placed in the folder `htb`   

very few web apps respect this RFC which leads to the possibility of registering almost infinite users by using a tag and only one actual email address 

### Predictable usernames 

in web apps with fewer UX requirements we may see usernames created sequentially 

may run into accounts like `user1000`, `user1001`, etc.  
same with admin users like `support.it`, `support.fr`, etc. 

an attacker can infer the algorithm used to create users and guess existing accounts starting from some known ones 

### Find a valid username Q1

our target uses the message "Invalid username." when attempting to login 

we can see that the site uses a GET request and running a simple wfuzz command to fuzz the username parameter results in the "puppet" username being found based on word length: 

![](Images/Pasted%20image%2020240219191108.png)
![](Images/Pasted%20image%2020240219191118.png)

### Find a valid username Q2

this target appears to send a request parameter `wronguser` when using invalid credentials: 

![](Images/Pasted%20image%2020240219191419.png)

you can also see that they are hidden form fields: 

![](Images/Pasted%20image%2020240219192910.png)

in the responses you can also see the `wronguser` field being filled: 

![](Images/Pasted%20image%2020240219193328.png)

but with a valid username you can see it instead set to `validuser`: 

![](Images/Pasted%20image%2020240219193411.png)

### Find a valid username Q3

in this example there is vague error text and no such descriptive request parameters or hidden form fields so now it might be appropriate to try the `timing.py` script to compare hashing times for the provided credentials: 

from this you can see that the user "vagrant" took a much longer time to respond: 

![](Images/Pasted%20image%2020240219193941.png)

### Find a valid username Q4 

this target has a registration form that after registering an account will provide a "thanks for registering" message: 

![](Images/Pasted%20image%2020240219194206.png)

then in burp intruder you can see that the response length of an already registered user is much longer: 

![](Images/Pasted%20image%2020240219194352.png)

## Brute Forcing Passwords 

after successful username enumeration, the attacker is usually one step away from bypassing authentication   
passwords are the primary security measure for most apps   

### Password issues 

often people think that a password is just a word and not a phrase  
users mostly only set passwords that are easy to remember   
many passwords saved in cleartext or post-it note   
also not uncommon to find password written in the hint field 

NIST modified its guidelines: 

```
Verifiers SHOULD NOT impose other composition rules (e.g., requiring mixtures of different character types or prohibiting consecutively repeated characters) for memorized secrets. Verifiers SHOULD NOT require memorized secrets to be changed arbitrarily (e.g., periodically).
```

it is also common for users to reuse passwords on multiple services - credential stuffing 

password managers are a good solution  

some places like ATMs use weak measures like PINs but are balanced by limitations on total attempts 

### Policy inference

the chances of executing a successful brute force attack increase after a policy evaluation   
knowing min password requirements lets the attacker only test compliant passwords   
strong password policies can make brute forces almost impossible  

as a developer, always choose long passwords over short+complex ones 

pretty much always possible to infer the password policy by registering a new user 

![](Images/Pasted%20image%2020240220141225.png)

policies define how many different families of characters are needed and the length of the password itself 

famillies: 
- lowercase characters (a-z)
- uppercase characters (A-Z)
- digits (0-9)
- special characters like `,./?! `

to guess policy requirements we can start with something like: 

`Qwertyiop123!@#`

then we can one by one remove families like special characters, numbers, etc. 

some limit length by forcing users to have password between 8-15 chars   
prone to error and possible that some combos will not be tested while others will be tested twice   

recommended to use a table like: 

![](Images/Pasted%20image%2020240220143306.png)

then once we have isolated the policy we can filter our dictionaries like with: 

```shell
grep '[[:upper:]]' rockyou.txt | grep '[[:lower:]]' | grep -E '^.{8,12}$' | wc -l
```

https://academy.hackthebox.com/storage/modules/80/password_policy_php.txt

always make sure to check if an anti-csrf token protects the form and modify the script to send such a token 

our target is a basic login form: 

![](Images/Pasted%20image%2020240220144125.png)

first to find the policy by testing different combinations: 
- `Qwertyiop123!@#` - valid 
- `Qwertyiop123` - valid 
- `Qwertyiop` - invalid 
- `qwertyiop123` - invalid 
- `Qwertyiop1` - valid 
- `QWERTYUIOP123` - valid

now that I can tell that uppercase and numbers are required but not lowercase, I can look for any length requirements: 
- `Qwertyuiopasdf123` - 17 chars valid
- `Q1` - valid

from this I can assume that the only real requirements are that the password have 1 uppercase and 1 number so I can now filter out the passwords list: 

`grep '[[:upper:]]' rockyou.txt | grep '[0-9]'`: 

![](Images/Pasted%20image%2020240220175834.png)

then with the specified list list you can find the password: 

![](Images/Pasted%20image%2020240220191803.png)

## Predictable Reset Token 

reset tokens in the form of a code or temp password are pieces of data generated mainly by the app when a password reset is requested  
must be provided to prove user's identity 
can also consider answers to security questions tokens as well 

![](Images/Pasted%20image%2020240220205001.png)

### Reset token by email 

if the app sends temp passwords by email then it should contain a robust token generation function 

most frameworks have built in functions to generate tokens but sometimes developers create their own which is more susceptible to attacks 

### Weak token generation 

some apps create tokens using known or predictable values like the local time or the username to then be hashed or encoded   
bad practice because a token doesn't need to contain any relevant info and should be completely random 

we should try to brute force any weak hash using known combos like time+username or time+email when a reset token is requested for a given user 

```php
<?php
function generate_reset_token($username) {
  $time = intval(microtime(true) * 1000);
  $token = md5($username . $time);
  return $token;
}
```

from code like the above the attacker can get the server time by reading the `Date header`   
then you can brute force the `$time` value in a matter of seconds to get a valid reset token 

https://academy.hackthebox.com/storage/modules/80/scripts/reset_token_time_php.txt
https://academy.hackthebox.com/storage/modules/80/scripts/reset_token_time_py.txt

in the above examples the app generates a token with an md5 hash of the current seconds since epoch and we can use the python script to brute force it 

sometimes the headers could be stripped or altered by reverse proxies but we can infer the time in different ways like the time of a sent or received in-app message, an email header, or last login time   

some apps don't check for the token age which gives attackers plenty of time   
sometimes the tokens aren't even invalidated or expired   

### Short tokens 

another bad practice is the use of short tokens   
usually to help mobile users, an app might generate a token of 5/6 chars   

no need to use short tokens because they are received by email and could be embedded in an HTTP link that could be validated with a get request like: 

`https://127.0.0.1/reset.php?token=any_random_sequence`

using wfuzz to fuzz a token of 5 digits we can test all digits between 00000-99999 and if the app responds with a message then we could do a reverse string match to filter responses that contain "Invalid token" with `--hs`: 

```shell
wfuzz -z range,00000-99999 --ss "Valid" "https://brokenauthentication.hackthebox.eu/token.php?user=admin&token=FUZZ"
```

### Weak cryptography 

sometimes developers try to create their own crypto routine which can lead to weak token randomness 

for example an app was found to be using `mt_rand()` in php which is known to be vulnerable due to lack of sufficient entropy   
having access to some insecure tokens makes it possible to identify the seed, which can lead to predicting any past and future token 

### Reset token as temp password 

some apps use reset tokens as actual temp passwords   
any temp password should be invalidated as soon as the user logs in and changes it   

always check if any reset tokens being used as temp passwords can be reused 

higher chances that temp passwords are being generated with predictable algorithms like mt_rand(), md5(), etc. so make sure to test the algorithm's security by looking at captured tokens 

if we have a vulnerable app that generates tokens: 

![](Images/Pasted%20image%2020240221105320.png)

attempting a fake token you can get the error message: 

![](Images/Pasted%20image%2020240221105415.png)

then in the reset_token_time.py script you can brute force a valid token for another user "htbadmin": 

```python
from hashlib import md5
import requests
from sys import exit
import time
from datetime import datetime

url = "http://94.237.49.138:41571/question1/"

time_str = "2024-02-21 09:18:22pm"

# Convert the string to a datetime object
dt_object = datetime.strptime(time_str, '%Y-%m-%d %I:%M:%S%p')

# Convert the datetime object to epoch time in seconds
epoch_time_seconds = int(dt_object.timestamp())

# Convert epoch time to milliseconds
epoch_time_milliseconds = epoch_time_seconds * 1000

start_time = epoch_time_milliseconds - 1200
end_time = epoch_time_milliseconds + 1200

username = "htbadmin"
fail_text = "Wrong token"

# loop from start_time to now. + 1 is needed because of how range() works
for x in range(start_time, end_time + 1):
    # get token md5
    md5_token = md5((username + str(x)).encode()).hexdigest()
    data = {
        "submit": "check",
        "token": md5_token
    }

    print("checking {} {}".format(str(x), md5_token))

    # send the request
    res = requests.post(url, data=data)

    # response text check
    if not fail_text in res.text:
        print(res.text)
        print("[*] Congratulations! raw reply printed before")
        exit()
```

in the other example we are given a long token that we can try different decodings of to find that it is simply a user-specific string converted into ASCII hex and then base64 

we can do the reverse of this string with the admin account to get a valid temp password: 

![](Images/Pasted%20image%2020240221134644.png)